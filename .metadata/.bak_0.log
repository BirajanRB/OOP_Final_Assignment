!SESSION 2023-04-11 02:37:46.376 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-11 02:37:48.849
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-11 02:37:59.099
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-11 02:38:03.893
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 02:38:03.893
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 02:38:03.893
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-11 02:38:06.744
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-11 12:11:17.633 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-11 12:11:18.663
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-11 12:11:28.866
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-11 12:11:30.550
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 12:11:30.550
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 12:11:30.550
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-11 12:11:33.416
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 02:08:59.667 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 02:09:02.101
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 02:09:06.664
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml
!SESSION 2023-04-12 02:20:23.822 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 02:20:24.747
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 02:20:29.951
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-12 02:20:31.044
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 02:20:31.044
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 02:20:31.044
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 02:20:33.883
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 11:22:05.507 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 11:22:09.366
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 11:22:38.800
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-12 11:22:46.475
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 11:22:46.475
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 11:22:46.475
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 11:22:51.927
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 16:34:56.927 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 16:34:58.337
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 16:35:01.958
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-12 16:35:03.288
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 16:35:03.288
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 16:35:03.289
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 16:35:06.096
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 17:53:27.299 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 17:53:28.277
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-12 17:53:35.678
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-12 17:53:36.918
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 17:53:36.918
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 17:53:36.918
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 17:53:39.327
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-13 11:31:32.583 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-13 11:31:36.508
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-13 11:31:46.650
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-13 11:31:54.512
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 11:31:54.512
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 11:31:54.512
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-13 11:31:59.760
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-14 03:14:33.505 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-14 03:14:35.928
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-14 03:14:40.905
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-14 03:14:46.187
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-14 03:14:46.188
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-14 03:14:46.188
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-14 03:14:49.599
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-14 16:51:30.339 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-14 16:51:32.656
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-14 16:51:37.960
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-14 16:51:42.534
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-14 16:51:42.534
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-14 16:51:42.534
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-14 16:51:45.580
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-15 03:20:46.742 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-15 03:20:47.765
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-15 03:20:51.001
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-15 03:20:52.316
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-15 03:20:52.316
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-15 03:20:52.316
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-15 03:20:55.237
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-16 03:02:54.644 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-16 03:02:57.139
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-16 03:03:01.301
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-16 03:03:06.520
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-16 03:03:06.520
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-16 03:03:06.520
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-16 03:03:11.156
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-16 04:28:50.567 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-16 04:28:51.430
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-16 04:28:53.681
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-16 04:28:54.854
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-16 04:28:54.854
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-16 04:28:54.854
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-16 04:28:57.364
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-16 05:38:59.752 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-16 05:39:00.605
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-16 05:39:02.591
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-16 05:39:03.733
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-16 05:39:03.733
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-16 05:39:03.734
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-16 05:39:06.447
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-17 07:20:39.589 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-17 07:20:42.104
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-17 07:20:46.212
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-17 07:20:51.295
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 07:20:51.295
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 07:20:51.295
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-17 07:20:55.408
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-17 12:24:00.518 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-17 12:24:04.606
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-17 12:24:20.150
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-17 12:24:28.232
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 12:24:28.232
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 12:24:28.232
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-17 12:24:33.702
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-19 06:04:33.916 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-19 06:04:37.362
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-19 06:07:20.446
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-19 06:07:27.434
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 06:07:27.434
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 06:07:27.434
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-19 06:07:31.605
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 07:26:09.857
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	protected boolean saveCounter = true;
	
	//Command Entered Buffer
	protected StringBuffer strBufferObj = new StringBuffer();
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);
        
        //about();
        reset();
        penDown();
	}
	
	public void about()
	{
		//overriding the about method.
		
		//calling the parent class about method.
		super.about();
	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void pencolour()
	{
		///////////////////////////////////////////////////////////////////////////
	}
	
	public void penwidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
		
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		
		double a,b,c,largestLengthC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//c2 - (a2+b2)
		(Math.pow(largestLengthC, b) - ( Math.pow(a, 2) + Math.pow(b, 2) );
		
		-2*a*b*Cos(angle);
		
		
		
	}
	
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		System.out.println("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","penwidth","triangle"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				System.out.println("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						System.out.println("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							System.out.println("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						System.out.println("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penwidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			System.out.println("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 07:26:09.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 07:26:09.859
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 07:26:10.511
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	protected boolean saveCounter = true;
	
	//Command Entered Buffer
	protected StringBuffer strBufferObj = new StringBuffer();
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);
        
        //about();
        reset();
        penDown();
	}
	
	public void about()
	{
		//overriding the about method.
		
		//calling the parent class about method.
		super.about();
	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void pencolour()
	{
		///////////////////////////////////////////////////////////////////////////
	}
	
	public void penwidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
		
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		
		double a,b,c,largestLengthC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//c2 - (a2+b2)
		( Math.pow(largestLengthC, b) - ( Math.pow(a, 2) + Math.pow(b, 2) );
		
		-2*a*b*Cos(angle);
		
		
		
	}
	
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		System.out.println("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","penwidth","triangle"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				System.out.println("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						System.out.println("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							System.out.println("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						System.out.println("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penwidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			System.out.println("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 07:26:10.512
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 07:26:10.512
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 07:26:10.951
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	protected boolean saveCounter = true;
	
	//Command Entered Buffer
	protected StringBuffer strBufferObj = new StringBuffer();
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);
        
        //about();
        reset();
        penDown();
	}
	
	public void about()
	{
		//overriding the about method.
		
		//calling the parent class about method.
		super.about();
	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void pencolour()
	{
		///////////////////////////////////////////////////////////////////////////
	}
	
	public void penwidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
		
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		
		double a,b,c,largestLengthC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//c2 - (a2+b2)
		( Math.pow(largestLengthC, b) - ( Math.pow(a, 2) + Math.pow(b, 2) );
		
		-2*a*b*Cos(angle);
		
		
		
	}
	
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		System.out.println("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","penwidth","triangle"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				System.out.println("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						System.out.println("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							System.out.println("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						System.out.println("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penwidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			System.out.println("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 07:26:10.952
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 07:26:10.952
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 07:41:03.512
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	protected boolean saveCounter = true;
	
	//Command Entered Buffer
	protected StringBuffer strBufferObj = new StringBuffer();
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);
        
        //about();
        reset();
        penDown();
	}
	
	public void about()
	{
		//overriding the about method.
		
		//calling the parent class about method.
		super.about();
	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void pencolour()
	{
		///////////////////////////////////////////////////////////////////////////
	}
	
	public void penwidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		
		double a,b,c,largestLengthC,value,angle;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		
		value =2( Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2)) ) - Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))  
				
				
				/ 2*a*b;
		
		
		angle = Math.acos(value); //Java Math acos() method returns the arc cosine of the specified value (cos^-1).
		
		System.out.println(angle);
		
		
		
		
		
	}
	
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		System.out.println("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","penwidth","triangle"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				System.out.println("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						System.out.println("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							System.out.println("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						System.out.println("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penwidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			System.out.println("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 07:41:03.512
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 07:41:03.513
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 07:41:03.522
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	protected boolean saveCounter = true;
	
	//Command Entered Buffer
	protected StringBuffer strBufferObj = new StringBuffer();
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);
        
        //about();
        reset();
        penDown();
	}
	
	public void about()
	{
		//overriding the about method.
		
		//calling the parent class about method.
		super.about();
	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void pencolour()
	{
		///////////////////////////////////////////////////////////////////////////
	}
	
	public void penwidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		
		double a,b,c,largestLengthC,value,angle;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		
		value =2( Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2)) ) - Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))  
				
				
				/ 2*a*b;
		
		
		angle = Math.acos(value); //Java Math acos() method returns the arc cosine of the specified value (cos^-1).
		
		System.out.println(angle);
		
		
		
		
		
	}
	
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		System.out.println("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","penwidth","triangle"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				System.out.println("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						System.out.println("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							System.out.println("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						System.out.println("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penwidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			System.out.println("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 07:41:03.523
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 07:41:03.523
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 07:41:04.510
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	protected boolean saveCounter = true;
	
	//Command Entered Buffer
	protected StringBuffer strBufferObj = new StringBuffer();
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);
        
        //about();
        reset();
        penDown();
	}
	
	public void about()
	{
		//overriding the about method.
		
		//calling the parent class about method.
		super.about();
	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void pencolour()
	{
		///////////////////////////////////////////////////////////////////////////
	}
	
	public void penwidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		
		double a,b,c,largestLengthC,value,angle;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		
		value =2( Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2)) ) - Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))  
				
				
				/ 2*a*b;
		
		
		angle = Math.acos(value); //Java Math acos() method returns the arc cosine of the specified value (cos^-1).
		
		System.out.println(angle);
		
		
		
		
		
	}
	
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		System.out.println("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","penwidth","triangle"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				System.out.println("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						System.out.println("Non numeric data for parameter");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							System.out.println("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						System.out.println("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							System.out.println("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						System.out.println("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penwidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						System.out.println("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			System.out.println("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 07:41:04.511
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 07:41:04.511
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-04-19 11:49:01.354 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-19 11:49:04.038
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-19 11:49:26.277
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-19 11:49:32.307
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 11:49:32.307
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 11:49:32.307
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-19 11:49:35.823
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-19 12:01:34.250 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-19 12:01:38.355
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-19 12:01:44.835
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-19 12:01:52.822
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 12:01:52.822
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 12:01:52.822
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-19 12:01:57.349
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-20 06:24:00.836 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-20 06:24:05.250
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-20 06:25:29.244
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-20 06:25:37.935
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 06:25:37.935
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 06:25:37.935
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-20 06:25:43.143
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-20 07:44:18.673 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-20 07:44:20.009
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-20 07:44:22.219
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-20 07:44:24.069
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 07:44:24.069
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 07:44:24.069
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-20 07:44:28.164
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-20 21:26:28.920 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-20 21:26:31.494
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-20 21:26:35.942
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-20 21:26:41.483
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 21:26:41.483
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 21:26:41.483
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-20 21:26:47.128
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-21 10:39:46.723 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-21 10:39:47.549
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-21 10:40:04.029
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-21 10:40:05.170
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-21 10:40:05.170
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-21 10:40:05.170
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-21 10:40:07.725
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-22 14:39:23.492 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-22 14:39:26.210
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-22 14:39:32.725
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-22 14:39:38.065
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-22 14:39:38.065
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-22 14:39:38.065
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-22 14:39:41.861
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-25 15:37:37.551 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-04-25 15:37:40.007
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-04-25 15:37:43.720
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-04-25 15:37:49.904
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-25 15:37:49.904
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-25 15:37:49.904
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-25 15:37:53.630
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-01 16:23:42.135 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-05-01 16:23:45.208
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-05-01 16:23:55.912
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-05-01 16:24:01.719
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 16:24:01.719
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 16:24:01.719
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-01 16:24:05.841
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-01 16:37:29.650 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-05-01 16:37:30.510
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-05-01 16:37:32.564
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-05-01 16:37:33.807
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 16:37:33.807
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 16:37:33.807
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-01 16:37:36.699
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-01 19:32:25.954 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-05-01 19:32:26.811
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-05-01 19:32:38.491
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-05-01 19:32:39.670
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 19:32:39.670
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 19:32:39.670
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-01 19:32:42.169
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-02 20:14:57.658 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=19.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-05-02 20:14:58.486
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-05-02 20:15:04.842
!MESSAGE Logback config file: C:\Birajan\The_British_College\TBC Bsc_Computing Sem4 L4\OOP Object Oriented Programming\OOP_Final_Assignment\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-05-02 20:15:06.031
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 20:15:06.031
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 20:15:06.031
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 20:15:08.765
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Asus'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:50.618
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = (s(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:02:50.619
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:02:50.620
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:52.203
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = (s(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:02:52.204
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:02:52.205
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:54.391
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:02:54.393
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:02:54.393
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:54.844
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:02:54.845
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:02:54.845
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:55.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s((s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:02:55.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:02:55.923
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:57.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:02:57.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:02:57.147
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:57.785
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:02:57.786
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:02:57.786
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:02:57.798
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-a)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:02:57.799
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:02:57.799
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:01.857
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-l)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:01.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:01.859
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:02.381
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-le)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:02.382
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:02.382
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:03.245
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-leng)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:03.246
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:03.246
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:03.257
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-lengh)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:03.258
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-lengh)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:03:03.258
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:03.259
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:03:03.259
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:03.260
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:05.151
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-lengh)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:03:05.152
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:03:05.152
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:07.330
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-leng)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:07.331
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:07.332
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:08.292
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:08.293
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:08.293
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:09.666
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-b)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:03:09.667
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:03:09.667
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:10.210
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:10.211
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:10.211
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:10.223
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:03:10.224
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:03:10.224
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:10.943
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-(s(s-a)(s-b)(s-c)))(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:10.944
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:10.945
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:12.363
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:12.364
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:12.365
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:13.805
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:03:13.807
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:03:13.807
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:14.592
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s- heron's formula.)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:14.593
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:14.593
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:15.769
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:15.770
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:15.770
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:17.712
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-02 22:03:17.713
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-02 22:03:17.714
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:21.418
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-length)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:21.419
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:21.419
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:22.619
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-length)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:22.620
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:22.621
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:23.393
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-length)(s-c))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:23.394
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:23.394
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:25.337
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-length)(s-length))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-02 22:03:25.338
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-02 22:03:25.338
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 22:03:26.036
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package graphicsProgramFinalAssignmentOOP;

import uk.ac.leedsbeckett.oop.LBUGraphics;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.*;
import javax.swing.JFrame;
import javax.swing.JOptionPane;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import java.util.Random;


public class GraphicsSystem extends LBUGraphics
{	
	//save counter
	private boolean saveCounter = true;
	
	//Command Entered Buffer
	private StringBuffer strBufferObj = new StringBuffer();
	
	//RGB mode counter
	private boolean rgbModeBool = false;
	
	public static void main(String[] args)
	{
		new GraphicsSystem();
	}
	
	
	public GraphicsSystem()
	{
        JFrame MainFrame = new JFrame();           
        MainFrame.setLayout(new FlowLayout());    
        MainFrame.add(this);                       
        MainFrame.setSize(850,450);               
        MainFrame.setVisible(true);   
        MainFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        MainFrame.addWindowListener(new WindowListenerClass());
        
        
        //about();
        reset();
        penDown();
	}
	

	
	public void about()
	{
		//overriding the about method.
	
		try
		{
			File loadImage = new File("name.png");
			BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
			setBufferedImage(bufferedImageObjLoad);
			
			System.out.println(1+2+"="+1+2);
		}
		catch(Exception e)
		{
			displayMessage("Error loading Name");
		}
		
		//calling the parent class about method.
		super.about();

	}
	
	public void square(int length)
	{	
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}

	}
	
	public void squareCentered(int length)
	{	
		//initial position.
		int xPos = getxPos();
		int yPos = getyPos();
		
		
		reset();
		forward(length/2);
		turnRight();
		forward(length/2);
		turnLeft();
		
		penDown();
		int i;
		for(i = 0;i<4;i++)
		{		
			turnLeft();
			forward(length);
		}
		
		//going back to the original position after this command has been issued.
		setxPos(xPos);
		setyPos(yPos);
		
		//fixing teleport issues.
		penUp();
		forward(0);
		penDown();
	}
	
	
	public void penColour(int colourR, int colourG, int colourB)
	{
		try
		{
			Color c = new Color(colourR,colourG,colourB);
			setPenColour(c);
		}
		catch(Exception e)
		{
			//In case our of bound arguments are given.
			displayMessage("Color parameter outside of expected range: Red:255 Green:255 Blue:255");
		}
	}
	
	
	public void penWidth(int width)
	{
		setStroke(width);
	}
	
	public void triangle(int length)
	{
		//Draws a triangle with equal sides.
		turnLeft();
		penDown();
			
		int i;
		for(i=0;i<3;i++)
		{
			
			forward(length);
			
			if(i<2)
			{
				turnLeft(120);
			}
			
		}
	}
	
	
	public void triangle(int lengthOne, int lengthTwo, int lengthThree)
	{	
		//overloading triangle function.
		//Draws a triangle with specific sides.
	
		double a,b,largestLengthC,angleA,angleB,angleC;
		
		if(lengthOne>lengthTwo && lengthOne>lengthThree)
		{
			//case where lengthOne is the largest
			
			a = lengthTwo;
			b = lengthThree;
			
			largestLengthC = lengthOne;
			
		}
		else if(lengthTwo>lengthOne && lengthTwo>lengthThree)
		{
			//case where lengthTwo is the largest
			a = lengthOne;
			b = lengthThree;
			
			largestLengthC = lengthTwo;
		}
		else
		{	
			//case where lengthThree is the largest
			a = lengthOne;
			b = lengthTwo;
			
			largestLengthC = lengthThree;
		}
		
				
		//Using Cosine Law to find the largest angle vai the longest side.
		//c^2 = a^2 + b^2 -2*a*b*Cos(angle)
		//Cos(angle) =  -(c^2 - (a^2+b^2)) / 2ab
		//angle = cos*-1( -(c^2 - (a^2+b^2)) / 2ab) )
		double value;
		value = -(Math.pow(largestLengthC, 2) - ( Math.pow(a, 2) + Math.pow(b, 2))) /(2*a*b) ;
		angleC = Math.toDegrees(Math.acos(value)); // returns the angleC degree
		
		//using Sine Law to find the other angles.
		//sideA/sinA = sideB/sinB = sideC/sinC
		//A = (sin(c)*a/c)sin^-1
		//B = (sin(c)*b/c)sin^-1
		angleA = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (a/largestLengthC) ) );
		angleB = Math.toDegrees( Math.asin( Math.sin(Math.toRadians(angleC)) * (b/largestLengthC) ) );
		
		turnLeft();
		forward((int) largestLengthC);
		
		turnLeft(180 - (int) angleB);
		forward((int) a);
		
		turnLeft(180 - (int) angleC );
		forward((int) b);
		
		turnLeft(180 - (int) angleA);
		
	}
	
	public void hexagram(int length)
	{
		//Heron's formula 
		//s = (a+b+c)/2
		//a = sq(s(s-a)(s-b)(s-c))
		int s = (length+length+lenght)/2;
		areaOfTriangle = s*(s-length)(s-length)(s-length))
		
				
		
		triangle(length);
		turnLeft(180);
		triangle(length);
	}
	
	public void rgbModeOn()
	{
		int[] rgbValue = {255,255,255};
		Random randObj = new Random();
		
		rgbModeBool = true;
		
		//Loops through the RGB value until RGB mode is turned off.
		while(rgbModeBool == true)
		{
			int i = randObj.nextInt(0,3);
			
			if(rgbValue[i] == 255)
			{
				while(rgbValue[i] > 0)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					--rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 	
					catch (InterruptedException e) 
					{
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
			else if(rgbValue[i]==0)
			{
				while(rgbValue[i] < 255)
				{
					penColour(rgbValue[0],rgbValue[1],rgbValue[2]);
					++rgbValue[i];
					
					try 
					{
						Thread.sleep(5);
					} 
					catch (InterruptedException e) 
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					if(rgbModeBool == false)
					{
						break;
					}
				}
			}
		}
		
	}
	
	public void rgbModeOff()
	{
		//Turns off RGB mode.
		rgbModeBool = false;
	}
	
	
	public void processCommand(String command)
	{	
		
		//Prints the Command Entered.
		displayMessage("Command Entered: "+command);
		
		//Splitting Entered Command into An array of String objects.
		String[] commandEntered = command.split(" ");
		
		//Method parameter values.
		int[] enteredParameterValue = new int[3];
		
		
		//Array of accepted commands.
		String[] commandCollection = {"about","penup","pendown","turnleft","turnright","forward","backward","black","green","red","white","reset","clear","save","load","square","squarecentered","pencolour","penwidth","triangle","hexagram","rgbmodeon","rgbmodeoff"};
		
		//Collection Class ArrayList for accepted commands.
		ArrayList acceptedCommandCollection = new ArrayList();
		
		for(String i: commandCollection)
		{	
			//Adding Accepted Commands
			acceptedCommandCollection.add(i);
		}
		
		
		//Command validation is done first.
		//parameter validation is done second.
		if(acceptedCommandCollection.contains(commandEntered[0].toLowerCase()))
		{
			//Valid Command Case.
			
			//Case where too many parameters are entered.
			if(commandEntered.length>4)
			{	
				displayMessage("Too many parameters entered.");
				
				//Ends function Execution in case of error.
				return;
			}
			
			//Parameter Filtering & conversion.
			switch(commandEntered.length)
			{		
				case 2:
					//One parameter Case
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
					
				case 3:
					//two parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;
								
				case 4:	
					//Three parameter Case.
					try
					{
						//Converting Entered String parameter into integer value.
						enteredParameterValue[0] = Integer.parseInt(commandEntered[1]);
						enteredParameterValue[1] = Integer.parseInt(commandEntered[2]);
						enteredParameterValue[2] = Integer.parseInt(commandEntered[3]);
					}
					catch(NumberFormatException exceptionName)
					{
						displayMessage("Non numeric data for parameter.");
						
						//Ends function Execution in case of error.
						return;
					}
					finally
					{
						//negative or non sensible values validation.
						if(enteredParameterValue[0]<0 || enteredParameterValue[1]<0 || enteredParameterValue[2]<0)
						{
							displayMessage("Negative or non sensible value is entered.");
							
							//Ends function Execution in case of negative or non sensible values.
							return;
						}
					}
					break;		
			}
			
			
			
			//Command filtering.
			switch(commandEntered[0].toLowerCase())
			{
				case "about":
					about();
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "reset":
					reset();
					penColour(255,0,0);	
					break;
					
				case "penup":
					penUp();
					break;
					
				case "pendown":
					penDown();
					break;
					
				case "turnleft":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnLeft(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnLeft();
					}
					break;
					
				case "turnright":
					
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						turnRight(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						turnRight();
					}				
					break;
					
				case "forward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "backward":
					if(commandEntered.length>1)
					{
						//Case where 2 parameter are given - command + value.
						forward(enteredParameterValue[0]-(enteredParameterValue[0]*2));
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made.
					saveCounter = false;
					break;
					
				case "black":					
					//Sets pen color to black.
					setPenColour(Color.black);
					break;
					
				case "green":
					//Sets pen color to green.
					setPenColour(Color.green);
					break;
					
				case "red":				
					//Sets pen color to red.
					setPenColour(Color.red);			
					break;
					
				case "white":
					//Sets pen color to white.
					setPenColour(Color.white);					
					break;
					
				case "clear":
					//Clears the display
					clear();
					
					//save counter True to symbolize saved status.
					saveCounter = true;
					break;
					
				case "save":
					try
					{
						//Save Image
						File savedImage = new File("savedImage.png");
						BufferedImage bufferedImageObjSave  = getBufferedImage();
						ImageIO.write(bufferedImageObjSave,"png", savedImage);
						
						//Saves Command
						File savedCommand = new File("savedCommand.txt");
						FileWriter fWriterObj = new FileWriter(savedCommand);
						BufferedWriter bWriterObj = new BufferedWriter(fWriterObj);
						bWriterObj.write(strBufferObj.toString());
						bWriterObj.close();
						
						//Clears the String buffer after each save.
						strBufferObj.delete(0,strBufferObj.length());
						
						//save counter True to symbolize saved status.
						saveCounter = true;
						
						//returns statement to avoid being added to the string command buffer
						return;						
					}
					catch(Exception e)
					{
						displayMessage("Error Saving Image");
					}	
					break;
					
				case "load":
					
					if(saveCounter == true)
					{
						try
						{	
							//reset turtle position.
							reset();
							penDown();
							
							//Load Image
							File loadImage = new File("savedImage.png");
							BufferedImage bufferedImageObjLoad = ImageIO.read(loadImage);
							setBufferedImage(bufferedImageObjLoad);
							
							
							//load Saved Commands.
							File savedCommand = new File("savedCommand.txt");
							FileReader fReaderObj = new FileReader(savedCommand);
							BufferedReader bReaderObj = new BufferedReader(fReaderObj);
													
							String line = bReaderObj.readLine(); //reads the first line of command file.
							while(line != null)
							{	
								processCommand(line);
								line = bReaderObj.readLine();
							}
							bReaderObj.close();
							
							//save counter True to symbolize saved status.
							saveCounter = true;
							
							//returns statement to avoid being added to the string command buffer
							return;
						}
						catch(Exception e)
						{
							displayMessage("Error Loading Image");
						}
					}
					else
					{	
						//Non-Saved image case.
						displayMessage("Current image/commands is not saved!");
						
						//returns statement to avoid being added to the string command buffer
						return;
					}
					break;
					
					
				case "square":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						square(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "squarecentered":
					//Centered version of square method.
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						squareCentered(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "pencolour":
					if(commandEntered.length==4)
					{
						//Case where parameter is given - command + value.
						penColour(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;
					
					
				case "penwidth":
					if(commandEntered.length>1)
					{
						//Case where parameter is given - command + value.
						penWidth(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					break;	
					
					
				case "triangle":
					if(commandEntered.length == 2)
					{
						//Case where one parameter is given - command + value.
						triangle(enteredParameterValue[0]);
					}
					else if(commandEntered.length == 4)
					{
						//Case where three parameter are given - command + parameter list.
						triangle(enteredParameterValue[0], enteredParameterValue[1], enteredParameterValue[2]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
				case "hexagram":
					if(commandEntered.length >= 2)
					{
						//Case where one parameter is given - command + value.
						hexagram(enteredParameterValue[0]);
					}
					else
					{
						//case where no parameter is given.
						displayMessage("Valid command with missing parameter.");
					}
					
					//save counter False to symbolize Unsaved status as changes have been made..
					saveCounter = false;
					break;	
					
					
				case "rgbmodeon":
					rgbModeOn();
					
					//Avoids being added to the string buffer/ saved commands
					return;
					
					
				case "rgbmodeoff":
					rgbModeOff();
					break;
					
			}
			
		}
		else
		{	
			//invalid Command Case.
			displayMessage("Invalid Command.");
		}
		
		
		//Commands Entered into string buffer
		strBufferObj.append(command+"\n");
		
	}
	
	
	
	//inner class
	//Adapter class of the WindowListener Interface
	private class WindowListenerClass extends WindowAdapter
	{

		public void windowClosing(WindowEvent event)
		{
			
			if(saveCounter == true)
			{
				event.getWindow().dispose();
			}
			else
			{
				int result = JOptionPane.showConfirmDialog(null, "The current image is not saved, do you wish to exit?");
				
				if(result == JOptionPane.YES_OPTION)
				{
					event.getWindow().dispose();
				}
			}
			
		}

	}
	
	
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
